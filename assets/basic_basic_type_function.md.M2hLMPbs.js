import{_ as s,c as i,o as a,U as t}from"./chunks/framework.vKaV7pYm.js";const g=JSON.parse('{"title":"函数","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"basic/basic_type/function.md","filePath":"basic/basic_type/function.md","lastUpdated":1704979746000}'),h={name:"basic/basic_type/function.md"},n=t(`<h1 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h1><blockquote><p>函数是编程语言中最为基本的语句。</p></blockquote><h2 id="基本使用" tabindex="-1">基本使用 <a class="header-anchor" href="#基本使用" aria-label="Permalink to &quot;基本使用&quot;">​</a></h2><p>zig 的函数明显，你可以一眼就看出来它的组成，我们来用一个简单的函数作为说明：</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">u8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">u8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">u8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>如果你有 C 的使用经验，一眼就可以看出来各自的作用。</p></blockquote><p>下面来进行说明：</p><ol><li><code>pub</code> 是访问修饰符，有且只有一个选择，那就是 <code>pub</code>，这代表着函数是公共可访问的（其他的文件import该文件后，可以直接使用这个函数）。</li><li><code>fn</code> 是关键字，代表着我们接下来定义了一个函数。</li><li><code>add</code> 是标识符，作为函数的名字。</li><li><code>a: u8</code> 是参数的标识符和类型，这里有两个参数，分别是 <code>a</code> 和 <code>b</code>，它们的类型均是 <code>u8</code>。</li><li><code>u8</code> 是函数的返回类型，在 zig 中，一个函数只能返回一个值。</li></ol><p>如果没有返回值，请使用 <code>void</code>，<strong><em>zig 原则上不允许忽略函数的返回值</em></strong>，如果需要忽略可将返回值分配给 <code>_</code>，编译器将自动忽略该返回值。</p><div class="info custom-block"><p class="custom-block-title">🅿️ 提示</p><p>你可能注意到了有的函数定义是这样子的：</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">comptime</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> else</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其中的 <code>comptime T: type</code> 你可能很陌生，这是<a href="./../../advanced/comptime.html">编译期</a>参数，它是用来实现鸭子类型（泛型）的关键语法！</p></div><details class="details custom-block"><summary>关于函数命名</summary><p>这里命名规则没什么强制性的要求，你只需要保证符合变量声明的 <a href="/basic/define-variable.html#标识符命名"><em>标识符规范</em></a> 即可。</p><p>如果你需要一个命名的推荐规则的话，可以参照 zig 源码的命名方式，它使用的是<a href="#">小驼峰命名法</a>。</p></details><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>函数体和函数指针之间是有区别的，函数体是仅限编译时的类型，而函数指针可能是运行时已知的。</p><p>关于函数指针，<code>*const fn (a: i8, b: i8) i8</code> 就是一个函数指针类型。</p></div><h2 id="参数传递" tabindex="-1">参数传递 <a class="header-anchor" href="#参数传递" aria-label="Permalink to &quot;参数传递&quot;">​</a></h2><blockquote><p>参数传递是一个非常古老的问题，在高级语言的角度来看，存在着“值传递”和“引用传递”这两种情况，这无疑大大增加了程序员在编程时的心智负担。</p></blockquote><p>zig 在这方面的处理则是，原始类型（整型、布尔这种）传递完全使用值传递，针对原始类型的这种策略开销非常小，通常只需要设置对应的寄存器即可。</p><p>像复合类型（结构体、联合、数组等），这些传递均是由编译器来决定究竟是使用“值传递”还是“引用传递”。</p><p>但作为开发者，只需要记住，<strong><em>函数的参数是不可变的</em></strong> 就行了。</p><div class="info custom-block"><p class="custom-block-title">🅿️ 提示</p><p>对于外部函数(使用 <code>extern</code> 修饰)，Zig 遵循 C ABI 按值传递结构和联合类型。</p></div><h2 id="内建函数" tabindex="-1">内建函数 <a class="header-anchor" href="#内建函数" aria-label="Permalink to &quot;内建函数&quot;">​</a></h2><p>内建函数由编译器提供，并以 <code>@</code> 为前缀。参数上的 <code>comptime</code> 关键字意味着该参数必须在编译期已知。</p><p>介于内建函数的数目过多，故不进行系统讲解，仅在对应章节说明涉及到的内建函数。</p><p>更多的内建函数文档请看 <a href="https://ziglang.org/documentation/master/#Builtin-Functions" target="_blank" rel="noreferrer">这里</a>。</p><h2 id="高阶使用" tabindex="-1">高阶使用 <a class="header-anchor" href="#高阶使用" aria-label="Permalink to &quot;高阶使用&quot;">​</a></h2><h3 id="anytype" tabindex="-1"><code>anytype</code> <a class="header-anchor" href="#anytype" aria-label="Permalink to &quot;\`anytype\`&quot;">​</a></h3><p>函数参数可以用 <code>anytype</code> 代替类型来声明。在这种情况下，调用函数时将推断参数类型。使用 <code>@TypeOf</code> 和 <code>@typeInfo</code> 获取有关推断类型的信息。</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addFortyTwo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">anytype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@TypeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="noreturn" tabindex="-1"><code>noreturn</code> <a class="header-anchor" href="#noreturn" aria-label="Permalink to &quot;\`noreturn\`&quot;">​</a></h3><p><code>noreturn</code> 是一个特殊的类型，它代表以下内容：</p><ul><li><code>break</code></li><li><code>continue</code></li><li><code>return</code></li><li><code>unreachable</code></li><li><code>while (true) {}</code></li></ul><p>当一个函数不会返回时，你可以使用它来代替 <code>void</code>。</p><p>该类型一般用在内核开发中，因为内核本身应当是一个不会退出的程序，还有一种使用场景是 <code>exit</code> 函数。</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extern</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;kernel32&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ExitProcess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">exit_code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">c_uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">callconv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">WINAPI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">noreturn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="extern" tabindex="-1"><code>extern</code> <a class="header-anchor" href="#extern" aria-label="Permalink to &quot;\`extern\`&quot;">​</a></h3><p><code>extern</code> 关键字保证函数可以在生成的 object 文件中可见，并且使用 C ABI。</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sub</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">🅿️ 提示</p><p>extern 关键字后面带引号的标识符指定具有该函数的库，例如 <code>c</code> -&gt; <code>libc.so</code>，<code>callconv</code> 说明符更改函数的调用约定。</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extern</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;c&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> atan2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></div><h3 id="setcold" tabindex="-1"><code>@setCold</code> <a class="header-anchor" href="#setcold" aria-label="Permalink to &quot;\`@setCold\`&quot;">​</a></h3><p><code>@setCold(comptime is_cold: bool) void</code></p><p>告诉优化器当前函数很少被调用（或不被调用），该函数仅在函数作用域内有效。</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> abort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">noreturn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @setCold</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="callconv" tabindex="-1"><code>callconv</code> <a class="header-anchor" href="#callconv" aria-label="Permalink to &quot;\`callconv\`&quot;">​</a></h3><p><code>callconv</code> 关键字告诉函数的调用约定，这在对外暴漏函数或者裸汇编时会很有用。</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 强制该函数在所有被调用位置内联，否则失败。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shiftLeftOne</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">u32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">callconv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(.</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Inline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">u32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>关于可以使用的调用约定格式，可以参考这里<a href="https://ziglang.org/documentation/master/std/#A;std:builtin.CallingConvention" target="_blank" rel="noreferrer"><code>std.builtin.CallingConvention</code></a>。</p>`,44),e=[n];function l(p,k,d,r,o,c){return a(),i("div",null,e)}const y=s(h,[["render",l]]);export{g as __pageData,y as default};
